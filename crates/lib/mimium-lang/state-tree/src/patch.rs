/// A patch to be applied to a flat state storage from old storage.
/// 
/// A patch represents a flat array copy operation from the source data storage
/// to the destination data storage.
#[derive(Debug, PartialEq, Eq, Clone, Hash)]
pub struct CopyFromPatch {
    /// Starting address in the source data storage (index from the beginning of the array)
    pub src_addr: usize,
    /// Starting address in the destination data storage
    pub dst_addr: usize,
    /// Size of data to copy (in u64 units)
    pub size: usize,
}

/// Apply patches to a new flat array.
///
/// # Arguments
/// * `new_storage` - Destination flat array with the new structure (initialized with zeros)
/// * `old_storage` - Source flat array with the old structure
/// * `patches` - List of patches generated by the `diff` function
///
/// # Panics
/// May panic if the addresses or sizes in the patches are invalid.
/// (This should not happen if `diff` is correctly implemented)
pub fn apply_patches(new_storage: &mut [u64], old_storage: &[u64], patches: &[CopyFromPatch]) {
    for patch in patches {
        let src_end = patch.src_addr + patch.size;
        let dst_end = patch.dst_addr + patch.size;
        
        debug_assert!(
            src_end <= old_storage.len(),
            "Source address range [{}, {}) exceeds old storage size {}",
            patch.src_addr,
            src_end,
            old_storage.len()
        );
        debug_assert!(
            dst_end <= new_storage.len(),
            "Destination address range [{}, {}) exceeds new storage size {}",
            patch.dst_addr,
            dst_end,
            new_storage.len()
        );
        
        // Perform flat array copy
        new_storage[patch.dst_addr..dst_end]
            .copy_from_slice(&old_storage[patch.src_addr..src_end]);
    }
}
