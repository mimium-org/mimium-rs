// Wasmtime-based WASM runtime
//
// This module provides execution of WASM modules generated by the WASM backend.
// It uses Wasmtime as the WASM runtime and bridges RuntimePrimitives to host functions.

pub mod engine;

use crate::runtime::primitives::Word;
use crate::runtime::vm::heap::{self, HeapStorage};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use wasmtime::{AsContextMut, Caller, Config, Engine, Linker, Module, OptLevel, Store};

/// WASM runtime state
pub struct WasmRuntime {
    /// Wasmtime engine
    engine: Engine,
    /// Linker for connecting host functions
    linker: Linker<RuntimeState>,
    /// Plugin loader (for calling plugin functions from host functions)
    #[cfg(not(target_arch = "wasm32"))]
    plugin_loader: Option<Arc<Mutex<crate::plugin::loader::PluginLoader>>>,
}

/// State storage for a single execution context (global or per-closure).
/// Mirrors the native VM's `StateStorage` struct.
#[derive(Debug, Clone, Default)]
struct StateStorage {
    /// Current read/write cursor in the data array
    pos: usize,
    /// Flat array of state words (delay buffers, mem values, etc.)
    data: Vec<u64>,
}

impl StateStorage {
    fn with_size(size: usize) -> Self {
        Self {
            pos: 0,
            data: vec![0u64; size],
        }
    }
}

/// Per-instance runtime state passed to host functions
pub struct RuntimeState {
    /// Linear memory pointer (set after instantiation)
    memory: Option<wasmtime::Memory>,
    /// Heap storage for dynamic allocations
    heap: HeapStorage,
    /// Array storage (array ID -> array data)
    arrays: HashMap<Word, Vec<Word>>,
    /// Global state storage (used at the top-level/global context)
    global_state: StateStorage,
    /// Per-closure state storages, keyed by closure address in linear memory.
    /// Each closure gets its own StateStorage, allocated lazily on first call.
    closure_states: HashMap<i64, StateStorage>,
    /// Stack of closure addresses for tracking the active state context.
    /// When empty, global_state is active. When non-empty, the top entry's
    /// closure state is active. Mirrors the native VM's `states_stack`.
    state_stack: Vec<i64>,
    /// Current time (for runtime_get_now)
    pub(crate) current_time: u64,
    /// Sample rate (for runtime_get_samplerate)
    pub(crate) sample_rate: f64,
    /// Plugin loader (for calling plugin functions)
    #[cfg(not(target_arch = "wasm32"))]
    plugins: Option<Arc<Mutex<crate::plugin::loader::PluginLoader>>>,
}

impl RuntimeState {
    /// Get the currently active state storage.
    /// Returns the global state if no closure is on the state stack,
    /// otherwise returns the state of the closure at the top of the stack.
    /// This mirrors the native VM's `get_current_state()` method.
    fn get_current_state(&mut self) -> &mut StateStorage {
        if let Some(&closure_addr) = self.state_stack.last() {
            self.closure_states
                .get_mut(&closure_addr)
                .expect("closure_state_push must be called before accessing closure state")
        } else {
            &mut self.global_state
        }
    }
}

impl Default for RuntimeState {
    fn default() -> Self {
        Self {
            memory: None,
            heap: HeapStorage::default(),
            arrays: HashMap::new(),
            global_state: StateStorage::default(),
            closure_states: HashMap::new(),
            state_stack: Vec::new(),
            current_time: 0,
            sample_rate: 44100.0,
            #[cfg(not(target_arch = "wasm32"))]
            plugins: None,
        }
    }
}

impl WasmRuntime {
    /// Create a new WASM runtime with JIT compilation
    pub fn new() -> Result<Self, String> {
        // Configure Wasmtime with JIT compiler and optimizations
        let mut config = Config::new();

        // Enable Cranelift JIT compiler with optimization level Speed
        config.cranelift_opt_level(OptLevel::Speed);

        // Enable parallel compilation for faster module loading
        config.parallel_compilation(true);

        // Enable WASM features that may improve performance
        config.wasm_simd(true); // SIMD operations
        config.wasm_bulk_memory(true); // Bulk memory operations

        let engine =
            Engine::new(&config).map_err(|e| format!("Failed to create WASM engine: {e}"))?;
        let mut linker = Linker::new(&engine);

        // Register all runtime primitive host functions
        Self::register_runtime_primitives(&mut linker)?;

        // Register plugin functions as host functions
        #[cfg(not(target_arch = "wasm32"))]
        let plugin_loader = Self::register_plugin_functions(&mut linker)?;

        Ok(Self {
            engine,
            linker,
            #[cfg(not(target_arch = "wasm32"))]
            plugin_loader,
        })
    }

    /// Load and instantiate a WASM module
    pub fn load_module(&mut self, wasm_bytes: &[u8]) -> Result<WasmModule, String> {
        let module = Module::from_binary(&self.engine, wasm_bytes)
            .map_err(|e| format!("Failed to load WASM module: {e:#}"))?;

        let mut runtime_state = RuntimeState::default();

        // Set plugin loader reference in runtime state
        #[cfg(not(target_arch = "wasm32"))]
        {
            runtime_state.plugins = self.plugin_loader.clone();
        }

        let mut store = Store::new(&self.engine, runtime_state);

        let instance = self
            .linker
            .instantiate(&mut store, &module)
            .map_err(|e| format!("Failed to instantiate WASM module: {e:#}"))?;

        // Get memory export
        let memory = instance
            .get_memory(&mut store, "memory")
            .ok_or("WASM module does not export memory")?;

        store.data_mut().memory = Some(memory);

        Ok(WasmModule {
            module,
            store,
            instance,
        })
    }

    /// Register all runtime primitive host functions
    fn register_runtime_primitives(linker: &mut Linker<RuntimeState>) -> Result<(), String> {
        macro_rules! register {
            ($($name:expr => $func:expr),* $(,)?) => {
                $(
                    linker
                        .func_wrap("runtime", $name, $func)
                        .map_err(|e| format!("Failed to register {}: {}", $name, e))?;
                )*
            };
        }

        register! {
            // Heap operations
            "heap_alloc" => heap_alloc_host,
            "heap_retain" => heap_retain_host,
            "heap_release" => heap_release_host,
            "heap_load" => heap_load_host,
            "heap_store" => heap_store_host,
            // Box operations
            "box_alloc" => box_alloc_host,
            "box_load" => box_load_host,
            "box_clone" => box_clone_host,
            "box_release" => box_release_host,
            "box_store" => box_store_host,
            // UserSum operations
            "usersum_clone" => usersum_clone_host,
            "usersum_release" => usersum_release_host,
            // Closure operations
            "closure_make" => closure_make_host,
            "closure_close" => closure_close_host,
            "closure_call" => closure_call_host,
            // Closure state stack operations (per-closure state isolation)
            "closure_state_push" => closure_state_push_host,
            "closure_state_pop" => closure_state_pop_host,
            // State operations
            "state_push" => state_push_host,
            "state_pop" => state_pop_host,
            "state_get" => state_get_host,
            "state_set" => state_set_host,
            "state_delay" => state_delay_host,
            "state_mem" => state_mem_host,
            // Array operations
            "array_alloc" => array_alloc_host,
            "array_get_elem" => array_get_elem_host,
            "array_set_elem" => array_set_elem_host,
            // Runtime globals
            "runtime_get_now" => runtime_get_now_host,
            "runtime_get_samplerate" => runtime_get_samplerate_host,
        }

        // Register math functions (from "math" module)
        linker
            .func_wrap(
                "math",
                "sin",
                |_caller: Caller<'_, RuntimeState>, x: f64| -> f64 { x.sin() },
            )
            .map_err(|e| format!("Failed to register math::sin: {e}"))?;
        linker
            .func_wrap(
                "math",
                "cos",
                |_caller: Caller<'_, RuntimeState>, x: f64| -> f64 { x.cos() },
            )
            .map_err(|e| format!("Failed to register math::cos: {e}"))?;
        linker
            .func_wrap(
                "math",
                "log",
                |_caller: Caller<'_, RuntimeState>, x: f64| -> f64 { x.ln() },
            )
            .map_err(|e| format!("Failed to register math::log: {e}"))?;
        linker
            .func_wrap(
                "math",
                "pow",
                |_caller: Caller<'_, RuntimeState>, base: f64, exp: f64| -> f64 { base.powf(exp) },
            )
            .map_err(|e| format!("Failed to register math::pow: {e}"))?;

        // Register builtin functions (from "builtin" module)
        macro_rules! register_builtin {
            ($($name:expr => $func:expr),* $(,)?) => {
                $(
                    linker
                        .func_wrap("builtin", $name, $func)
                        .map_err(|e| format!("Failed to register builtin::{}: {}", $name, e))?;
                )*
            };
        }

        register_builtin! {
            "probeln" => builtin_probeln_host,
            "probe" => builtin_probe_host,
            "length_array" => builtin_length_array_host,
            "split_head" => builtin_split_head_host,
            "split_tail" => builtin_split_tail_host,
        }

        Ok(())
    }

    /// Register plugin functions as host functions
    #[cfg(not(target_arch = "wasm32"))]
    fn register_plugin_functions(
        linker: &mut Linker<RuntimeState>,
    ) -> Result<Option<Arc<Mutex<crate::plugin::loader::PluginLoader>>>, String> {
        use crate::plugin::loader::PluginLoader;

        let mut loader = PluginLoader::new();
        loader
            .load_builtin_plugins()
            .map_err(|e| format!("Failed to load plugins: {e}"))?;

        // Get type infos to know function signatures
        let type_infos = loader.get_type_infos();

        // Wrap loader in Arc<Mutex<>> for sharing with host functions
        let loader = Arc::new(Mutex::new(loader));
        let loader_clone = loader.clone();

        for type_info in type_infos {
            let name = type_info.name;

            // For now, hardcode sampler_mono as example
            // TODO: Generate trampolines automatically based on type info
            if name.as_str() == "sampler_mono" {
                eprintln!("[D] Registering plugin host function: sampler_mono");

                linker
                    .func_wrap(
                        "plugin",
                        "sampler_mono",
                        move |caller: Caller<RuntimeState>, path_ptr: i32, path_len: i32| -> f64 {
                            // Read string from linear memory
                            let memory = caller.data().memory.expect("Memory not set");
                            let mem_data = memory.data(&caller);

                            let start = path_ptr as usize;
                            let end = start + path_len as usize;

                            if end > mem_data.len() {
                                eprintln!(
                                    "[E] Invalid memory access: ptr={path_ptr}, len={path_len}, mem_size={}",
                                    mem_data.len()
                                );
                                return 0.0;
                            }

                            let path_bytes = &mem_data[start..end];
                            let path_str = match std::str::from_utf8(path_bytes) {
                                Ok(s) => s,
                                Err(e) => {
                                    eprintln!("[E] Invalid UTF-8 in path string: {e}");
                                    return 0.0;
                                }
                            };

                            log::debug!("Plugin call: sampler_mono(\"{path_str}\")");

                            // Call plugin function via stored loader
                            // Note: This is a simplified implementation
                            // Real implementation would need to properly handle the plugin API

                            // For now, return a dummy value
                            // TODO: Actually call the plugin function
                            0.0
                        },
                    )
                    .map_err(|e| format!("Failed to register sampler_mono: {e}"))?;
            }
        }

        Ok(Some(loader_clone))
    }
}

impl Default for WasmRuntime {
    fn default() -> Self {
        Self::new().expect("Failed to create WASM runtime")
    }
}

/// WASM module instance
pub struct WasmModule {
    #[allow(dead_code)]
    module: Module,
    store: Store<RuntimeState>,
    instance: wasmtime::Instance,
}

impl WasmModule {
    /// Call a function exported by the WASM module
    pub fn call_function(&mut self, name: &str, args: &[Word]) -> Result<Vec<Word>, String> {
        let func = self
            .instance
            .get_func(&mut self.store, name)
            .ok_or_else(|| format!("Function '{name}' not found in WASM module"))?;

        // Convert args to wasmtime values
        let wasm_args: Vec<wasmtime::Val> =
            args.iter().map(|&w| wasmtime::Val::I64(w as i64)).collect();

        // Prepare results buffer
        let mut results = vec![wasmtime::Val::I64(0); func.ty(&self.store).results().len()];

        // Call function
        func.call(&mut self.store, &wasm_args, &mut results)
            .map_err(|e| format!("Failed to call function '{name}': {e}"))?;

        // Convert results back to Words
        Ok(results
            .into_iter()
            .map(|v| match v {
                wasmtime::Val::I64(i) => i as u64,
                wasmtime::Val::F64(f) => f, // Already in bits representation
                wasmtime::Val::I32(i) => i as u64,
                wasmtime::Val::F32(f) => f as u64, // Already in bits representation
                _ => 0,
            })
            .collect())
    }

    /// Read an f64 value from linear memory at the given byte offset
    pub fn read_memory_f64(&mut self, offset: usize) -> Result<f64, String> {
        let memory = self
            .instance
            .get_memory(&mut self.store, "memory")
            .ok_or("No memory export")?;
        let data = memory.data(&self.store);
        if offset + 8 > data.len() {
            return Err(format!(
                "Memory read out of bounds: offset={offset}, memory size={}",
                data.len()
            ));
        }
        let bytes: [u8; 8] = data[offset..offset + 8]
            .try_into()
            .map_err(|e| format!("Failed to read memory: {e}"))?;
        Ok(f64::from_le_bytes(bytes))
    }

    /// Get mutable access to the runtime state
    /// This allows external code to update current_time, sample_rate, etc.
    pub fn get_runtime_state_mut(&mut self) -> Option<&mut RuntimeState> {
        Some(self.store.data_mut())
    }
}

// Host function implementations

fn heap_alloc_host(mut caller: Caller<'_, RuntimeState>, size_words: i32) -> i64 {
    log::trace!("heap_alloc_host: size_words={size_words}");
    let state = caller.data_mut();
    let heap_obj = heap::HeapObject::new(size_words as usize);
    let heap_idx = state.heap.insert(heap_obj);

    // Convert HeapIdx to Word for WASM
    // We use the slotmap key's internal representation
    unsafe { std::mem::transmute::<heap::HeapIdx, u64>(heap_idx) as i64 }
}

fn heap_retain_host(mut caller: Caller<'_, RuntimeState>, obj: i64) {
    log::trace!("heap_retain_host: obj={obj}");
    let state = caller.data_mut();
    let heap_idx: heap::HeapIdx = unsafe { std::mem::transmute::<u64, heap::HeapIdx>(obj as u64) };
    heap::heap_retain(&mut state.heap, heap_idx);
}

fn heap_release_host(mut caller: Caller<'_, RuntimeState>, obj: i64) {
    log::trace!("heap_release_host: obj={obj}");
    let state = caller.data_mut();
    let heap_idx: heap::HeapIdx = unsafe { std::mem::transmute::<u64, heap::HeapIdx>(obj as u64) };
    heap::heap_release(&mut state.heap, heap_idx);
}

fn heap_load_host(mut caller: Caller<'_, RuntimeState>, dst_ptr: i32, obj: i64, size_words: i32) {
    log::trace!("heap_load_host: dst_ptr={dst_ptr}, obj={obj}, size_words={size_words}");

    let heap_idx: heap::HeapIdx = unsafe { std::mem::transmute::<u64, heap::HeapIdx>(obj as u64) };
    let size = size_words as usize;

    // Get heap data
    let data = {
        let state = caller.data();
        state
            .heap
            .get(heap_idx)
            .map(|heap_obj| heap_obj.data[..size].to_vec())
            .expect("heap_load: invalid heap index")
    };

    // Write to linear memory
    let memory = caller.data().memory.expect("Memory not initialized");
    let offset = dst_ptr as usize;
    let bytes = unsafe {
        std::slice::from_raw_parts(
            data.as_ptr() as *const u8,
            size * std::mem::size_of::<Word>(),
        )
    };
    memory
        .write(&mut caller, offset, bytes)
        .expect("Failed to write to WASM memory");
}

fn heap_store_host(mut caller: Caller<'_, RuntimeState>, obj: i64, src_ptr: i32, size_words: i32) {
    log::trace!("heap_store_host: obj={obj}, src_ptr={src_ptr}, size_words={size_words}");

    let heap_idx: heap::HeapIdx = unsafe { std::mem::transmute::<u64, heap::HeapIdx>(obj as u64) };
    let size = size_words as usize;

    // Read from linear memory
    let mut buffer = vec![0u64; size];
    let memory = caller.data().memory.expect("Memory not initialized");
    let offset = src_ptr as usize;
    let bytes = unsafe {
        std::slice::from_raw_parts_mut(
            buffer.as_mut_ptr() as *mut u8,
            size * std::mem::size_of::<Word>(),
        )
    };
    memory
        .read(&caller, offset, bytes)
        .expect("Failed to read from WASM memory");

    // Write to heap
    let state = caller.data_mut();
    let heap_obj = state
        .heap
        .get_mut(heap_idx)
        .expect("heap_store: invalid heap index");
    heap_obj.data[..size].copy_from_slice(&buffer[..size]);
}

fn box_alloc_host(mut caller: Caller<'_, RuntimeState>, src_ptr: i32, size_words: i32) -> i64 {
    log::trace!("box_alloc_host: src_ptr={src_ptr}, size_words={size_words}");

    let size = size_words as usize;

    // Read from linear memory
    let mut buffer = vec![0u64; size];
    let memory = caller.data().memory.expect("Memory not initialized");
    let offset = src_ptr as usize;
    let bytes = unsafe {
        std::slice::from_raw_parts_mut(
            buffer.as_mut_ptr() as *mut u8,
            size * std::mem::size_of::<Word>(),
        )
    };
    memory
        .read(&caller, offset, bytes)
        .expect("Failed to read from WASM memory");

    // Create heap object
    let state = caller.data_mut();
    let heap_obj = heap::HeapObject::with_data(buffer);
    let heap_idx = state.heap.insert(heap_obj);

    unsafe { std::mem::transmute::<heap::HeapIdx, u64>(heap_idx) as i64 }
}

fn box_load_host(caller: Caller<'_, RuntimeState>, dst_ptr: i32, obj: i64, size_words: i32) {
    log::trace!("box_load_host: dst_ptr={dst_ptr}, obj={obj}, size_words={size_words}");

    // Same as heap_load
    heap_load_host(caller, dst_ptr, obj, size_words);
}

fn box_clone_host(mut caller: Caller<'_, RuntimeState>, obj: i64) {
    log::trace!("box_clone_host: obj={obj}");

    // Same as heap_retain
    let state = caller.data_mut();
    let heap_idx: heap::HeapIdx = unsafe { std::mem::transmute::<u64, heap::HeapIdx>(obj as u64) };
    heap::heap_retain(&mut state.heap, heap_idx);
}

fn box_release_host(mut caller: Caller<'_, RuntimeState>, obj: i64) {
    log::trace!("box_release_host: obj={obj}");

    // Same as heap_release
    let state = caller.data_mut();
    let heap_idx: heap::HeapIdx = unsafe { std::mem::transmute::<u64, heap::HeapIdx>(obj as u64) };
    heap::heap_release(&mut state.heap, heap_idx);
}

fn box_store_host(caller: Caller<'_, RuntimeState>, obj: i64, src_ptr: i32, size_words: i32) {
    log::trace!("box_store_host: obj={obj}, src_ptr={src_ptr}, size_words={size_words}");

    // Same as heap_store
    heap_store_host(caller, obj, src_ptr, size_words);
}

// UserSum operations

fn usersum_clone_host(_caller: Caller<'_, RuntimeState>, dst_ptr: i32, src_ptr: i32, size: i32) {
    // TODO: Implement actual usersum clone (copy via linear memory)
    log::trace!("usersum_clone_host: dst_ptr={dst_ptr}, src_ptr={src_ptr}, size={size}");
}

fn usersum_release_host(_caller: Caller<'_, RuntimeState>, ptr: i32, tag: i32, size: i32) {
    // TODO: Implement actual usersum release
    log::trace!("usersum_release_host: ptr={ptr}, tag={tag}, size={size}");
}

// Closure operations

fn closure_make_host(
    _caller: Caller<'_, RuntimeState>,
    fn_idx: i64,
    captured_ptr: i32,
    captured_size: i32,
) -> i64 {
    // TODO: Implement actual closure creation
    log::trace!(
        "closure_make_host: fn_idx={fn_idx}, captured_ptr={captured_ptr}, captured_size={captured_size}"
    );
    0 // Placeholder
}

fn closure_close_host(_caller: Caller<'_, RuntimeState>, closure: i64) {
    // TODO: Implement actual closure closing
    log::trace!("closure_close_host: closure={closure}");
}

fn closure_call_host(
    _caller: Caller<'_, RuntimeState>,
    closure: i64,
    args_ptr: i32,
    args_size: i32,
    dst_ptr: i32,
    dst_size: i32,
) {
    // TODO: Implement actual closure call
    log::trace!(
        "closure_call_host: closure={closure}, args_ptr={args_ptr}, args_size={args_size}, dst_ptr={dst_ptr}, dst_size={dst_size}"
    );
}

// Closure state stack operations
// These mirror the native VM's states_stack.push/pop pattern.
// When a closure is called, its state storage is activated;
// when the call returns, the previous state context is restored.

/// Push a closure's state onto the state stack, making it the active state context.
/// Called before a closure call (CallCls/CallIndirect).
/// `closure_addr` is the closure's address in WASM linear memory (used as a unique key).
/// `state_size` is the number of words needed for this closure's state storage
/// (computed from state_skeleton.total_size() at compile time).
fn closure_state_push_host(
    mut caller: Caller<'_, RuntimeState>,
    closure_addr: i64,
    state_size: i64,
) {
    log::trace!("closure_state_push_host: closure_addr={closure_addr}, state_size={state_size}");
    let state = caller.data_mut();
    // Push closure address onto the state stack
    state.state_stack.push(closure_addr);
    // Lazily allocate state storage for this closure if it doesn't exist yet
    state
        .closure_states
        .entry(closure_addr)
        .or_insert_with(|| StateStorage::with_size(state_size as usize));
}

/// Pop the closure state stack, restoring the previous state context.
/// Called after a closure call returns.
fn closure_state_pop_host(mut caller: Caller<'_, RuntimeState>) {
    log::trace!("closure_state_pop_host");
    let state = caller.data_mut();
    // Reset pos of the outgoing closure's state for next call
    if let Some(&closure_addr) = state.state_stack.last() {
        if let Some(cls_state) = state.closure_states.get_mut(&closure_addr) {
            cls_state.pos = 0;
        }
    }
    state.state_stack.pop();
}

// State operations

/// Push the state position cursor forward by `offset` words.
/// Mirrors the native VM's `PushStatePos` instruction.
fn state_push_host(mut caller: Caller<'_, RuntimeState>, offset: i64) {
    log::trace!("state_push_host: offset={offset}");
    let state = caller.data_mut();
    let current = state.get_current_state();
    current.pos += offset as usize;
}

/// Pop the state position cursor back by `offset` words.
/// Mirrors the native VM's `PopStatePos` instruction.
fn state_pop_host(mut caller: Caller<'_, RuntimeState>, offset: i64) {
    log::trace!("state_pop_host: offset={offset}");
    let state = caller.data_mut();
    let current = state.get_current_state();
    current.pos -= offset as usize;
}

/// Read state data from the current state storage and write to WASM linear memory.
/// Mirrors the native VM's `GetState` instruction.
fn state_get_host(mut caller: Caller<'_, RuntimeState>, dst_ptr: i32, size_words: i32) {
    log::trace!("state_get_host: dst_ptr={dst_ptr}, size_words={size_words}");

    let size = size_words as usize;

    // Read from the active state storage at its current position
    let state_values: Vec<u64> = {
        let state = caller.data_mut();
        let current = state.get_current_state();
        let pos = current.pos;
        let needed = pos + size;
        if needed <= current.data.len() {
            current.data[pos..pos + size].to_vec()
        } else {
            // State not yet initialized at this position, return zeros
            vec![0u64; size]
        }
    };

    // Write to WASM linear memory
    let memory = caller.data().memory.expect("Memory not initialized");
    let bytes: Vec<u8> = state_values.iter().flat_map(|w| w.to_le_bytes()).collect();

    memory
        .write(&mut caller.as_context_mut(), dst_ptr as usize, &bytes)
        .expect("Failed to write state to WASM memory");
}

/// Write values from WASM linear memory to the current state storage.
/// Mirrors the native VM's `SetState` instruction.
fn state_set_host(mut caller: Caller<'_, RuntimeState>, src_ptr: i32, size_words: i32) {
    log::trace!("state_set_host: src_ptr={src_ptr}, size_words={size_words}");

    let size = size_words as usize;

    // Read from WASM linear memory
    let state_values: Vec<u64> = {
        let memory = caller.data().memory.expect("Memory not initialized");
        let mut bytes = vec![0u8; size * std::mem::size_of::<Word>()];
        memory
            .read(&caller, src_ptr as usize, &mut bytes)
            .expect("Failed to read from WASM memory");
        bytes
            .chunks(std::mem::size_of::<Word>())
            .map(|chunk| {
                let mut word_bytes = [0u8; 8];
                word_bytes.copy_from_slice(chunk);
                u64::from_le_bytes(word_bytes)
            })
            .collect()
    };

    // Write to the active state storage at its current position
    let state = caller.data_mut();
    let current = state.get_current_state();
    let pos = current.pos;
    let needed = pos + size;

    // Grow data if needed
    if needed > current.data.len() {
        current.data.resize(needed, 0);
    }

    current.data[pos..pos + size].copy_from_slice(&state_values);
}

/// Ring buffer delay: reads delayed value from state, writes new input.
/// State layout at current pos: [read_idx, write_idx, data[0..max_len]]
fn state_delay_host(
    mut caller: Caller<'_, RuntimeState>,
    input: f64,
    time: f64,
    max_len: i64,
) -> f64 {
    let state = caller.data_mut();
    let current = state.get_current_state();
    let pos = current.pos;
    let buf_size = max_len as usize;
    let total_needed = pos + 2 + buf_size;

    // Ensure data is large enough
    if total_needed > current.data.len() {
        current.data.resize(total_needed, 0);
    }

    let read_idx = current.data[pos];
    let time_samples = time as u64;
    let write_idx = (read_idx + time_samples) % buf_size as u64;

    // Read delayed value from ring buffer
    let res_bits = current.data[pos + 2 + read_idx as usize];
    let res = f64::from_bits(res_bits);

    // Write input to ring buffer
    current.data[pos + 2 + write_idx as usize] = input.to_bits();

    // Advance read index
    current.data[pos] = (read_idx + 1) % buf_size as u64;
    current.data[pos + 1] = write_idx;

    res
}

/// One-sample delay (mem): returns previous value, stores new input.
/// State layout at current pos: [value] (1 word)
fn state_mem_host(mut caller: Caller<'_, RuntimeState>, input: f64) -> f64 {
    let state = caller.data_mut();
    let current = state.get_current_state();
    let pos = current.pos;
    let needed = pos + 1;

    if needed > current.data.len() {
        current.data.resize(needed, 0);
    }

    let old_bits = current.data[pos];
    let old_value = f64::from_bits(old_bits);
    current.data[pos] = input.to_bits();

    old_value
}

// Array operations

fn array_alloc_host(mut caller: Caller<'_, RuntimeState>, src_ptr: i64, size: i32) -> i64 {
    log::trace!("array_alloc_host: src_ptr={src_ptr}, size={size}");

    let size_usize = size as usize;

    // Read from linear memory (src_ptr is i64 but used as memory offset)
    let mut buffer = vec![0u64; size_usize];
    let memory = caller.data().memory.expect("Memory not initialized");
    let offset = src_ptr as usize;
    let bytes = unsafe {
        std::slice::from_raw_parts_mut(
            buffer.as_mut_ptr() as *mut u8,
            size_usize * std::mem::size_of::<Word>(),
        )
    };
    memory
        .read(&caller, offset, bytes)
        .expect("Failed to read from WASM memory");

    // Generate unique array ID
    let state = caller.data_mut();
    let array_id = (state.arrays.len() + 1) as Word;
    state.arrays.insert(array_id, buffer);

    array_id as i64
}

fn array_get_elem_host(
    mut caller: Caller<'_, RuntimeState>,
    dst_ptr: i32,
    array: i64,
    index: i64,
    elem_size: i32,
) {
    log::trace!(
        "array_get_elem_host: dst_ptr={dst_ptr}, array={array}, index={index}, elem_size={elem_size}"
    );

    let idx = index as usize;
    let elem_words = elem_size as usize;

    // Get element data from array storage (multi-word aware)
    let data = {
        let state = caller.data();
        let array_data = state
            .arrays
            .get(&(array as Word))
            .expect("array_get_elem: invalid array ID");
        let base = idx * elem_words;
        if base + elem_words > array_data.len() {
            panic!(
                "array_get_elem: index {} out of bounds (base={}, elem_words={}, len={})",
                idx,
                base,
                elem_words,
                array_data.len()
            );
        }
        array_data[base..base + elem_words].to_vec()
    };

    // Write element data to linear memory at dst_ptr
    let memory = caller.data().memory.expect("Memory not initialized");
    let bytes = unsafe {
        std::slice::from_raw_parts(
            data.as_ptr() as *const u8,
            elem_words * std::mem::size_of::<Word>(),
        )
    };
    memory
        .write(&mut caller, dst_ptr as usize, bytes)
        .expect("Failed to write to WASM memory");
}

fn array_set_elem_host(
    mut caller: Caller<'_, RuntimeState>,
    array: i64,
    index: i64,
    src_ptr: i32,
    elem_size: i32,
) {
    log::trace!(
        "array_set_elem_host: array={array}, index={index}, src_ptr={src_ptr}, elem_size={elem_size}"
    );

    let idx = index as usize;
    let elem_words = elem_size as usize;

    // Read element from linear memory
    let mut buffer = vec![0u64; elem_words];
    let memory = caller.data().memory.expect("Memory not initialized");
    let bytes = unsafe {
        std::slice::from_raw_parts_mut(
            buffer.as_mut_ptr() as *mut u8,
            elem_words * std::mem::size_of::<Word>(),
        )
    };
    memory
        .read(&caller, src_ptr as usize, bytes)
        .expect("Failed to read from WASM memory");

    // Write to array storage (multi-word aware)
    let state = caller.data_mut();
    let array_data = state
        .arrays
        .get_mut(&(array as Word))
        .expect("array_set_elem: invalid array ID");
    let base = idx * elem_words;
    if base + elem_words > array_data.len() {
        panic!("array_set_elem: index out of bounds");
    }
    array_data[base..base + elem_words].copy_from_slice(&buffer);
}

// Runtime globals

fn runtime_get_now_host(caller: Caller<'_, RuntimeState>) -> f64 {
    log::trace!("runtime_get_now_host");
    let state = caller.data();
    state.current_time as f64
}

fn runtime_get_samplerate_host(caller: Caller<'_, RuntimeState>) -> f64 {
    log::trace!("runtime_get_samplerate_host");
    let state = caller.data();
    state.sample_rate
}

// Builtin function host implementations

fn builtin_probeln_host(_caller: Caller<'_, RuntimeState>, x: f64) -> f64 {
    println!("{x}");
    x
}

fn builtin_probe_host(_caller: Caller<'_, RuntimeState>, x: f64) -> f64 {
    print!("{x}");
    x
}

fn builtin_length_array_host(caller: Caller<'_, RuntimeState>, array: i64) -> f64 {
    log::trace!("builtin_length_array_host: array={array}");
    let state = caller.data();
    let array_data = state
        .arrays
        .get(&(array as Word))
        .expect("length_array: invalid array ID");
    array_data.len() as f64
}

fn builtin_split_head_host(mut caller: Caller<'_, RuntimeState>, array: i64, dst_ptr: i32) {
    log::trace!("builtin_split_head_host: array={array}, dst_ptr={dst_ptr}");

    let (head, rest_data) = {
        let state = caller.data();
        let array_data = state
            .arrays
            .get(&(array as Word))
            .expect("split_head: invalid array ID");
        assert!(!array_data.is_empty(), "Cannot split_head on empty array");
        let head = f64::from_bits(array_data[0]);
        let rest_data: Vec<u64> = array_data[1..].to_vec();
        (head, rest_data)
    };

    // Allocate new array for rest
    let rest_id = {
        let state = caller.data_mut();
        let rest_id = (state.arrays.len() + 1) as Word;
        state.arrays.insert(rest_id, rest_data);
        rest_id
    };

    // Write result tuple (head: f64, rest: i64) to linear memory at dst_ptr
    let memory = caller.data().memory.expect("Memory not initialized");
    let head_bytes = head.to_le_bytes();
    memory
        .write(&mut caller, dst_ptr as usize, &head_bytes)
        .expect("split_head: failed to write head");
    let rest_bytes = (rest_id as i64).to_le_bytes();
    memory
        .write(&mut caller, (dst_ptr + 8) as usize, &rest_bytes)
        .expect("split_head: failed to write rest");
}

fn builtin_split_tail_host(mut caller: Caller<'_, RuntimeState>, array: i64, dst_ptr: i32) {
    log::trace!("builtin_split_tail_host: array={array}, dst_ptr={dst_ptr}");

    let (tail, rest_data) = {
        let state = caller.data();
        let array_data = state
            .arrays
            .get(&(array as Word))
            .expect("split_tail: invalid array ID");
        assert!(!array_data.is_empty(), "Cannot split_tail on empty array");
        let len = array_data.len();
        let tail = f64::from_bits(array_data[len - 1]);
        let rest_data: Vec<u64> = array_data[..len - 1].to_vec();
        (tail, rest_data)
    };

    // Allocate new array for rest
    let rest_id = {
        let state = caller.data_mut();
        let rest_id = (state.arrays.len() + 1) as Word;
        state.arrays.insert(rest_id, rest_data);
        rest_id
    };

    // Write result tuple (rest: i64, tail: f64) to linear memory at dst_ptr
    let memory = caller.data().memory.expect("Memory not initialized");
    let rest_bytes = (rest_id as i64).to_le_bytes();
    memory
        .write(&mut caller, dst_ptr as usize, &rest_bytes)
        .expect("split_tail: failed to write rest");
    let tail_bytes = tail.to_le_bytes();
    memory
        .write(&mut caller, (dst_ptr + 8) as usize, &tail_bytes)
        .expect("split_tail: failed to write tail");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_wasm_runtime_create() {
        let runtime = WasmRuntime::new();
        assert!(runtime.is_ok(), "Should create WASM runtime");
    }

    #[test]
    fn test_wasm_runtime_load_empty_module() {
        let mut runtime = WasmRuntime::new().unwrap();

        // Minimal valid WASM module with memory export
        let wasm_bytes = wat::parse_str(
            r#"
            (module
                (memory (export "memory") 1)
            )
            "#,
        )
        .expect("Failed to parse WAT");

        let result = runtime.load_module(&wasm_bytes);
        assert!(result.is_ok(), "Should load minimal WASM module");
    }

    #[test]
    fn test_heap_operations() {
        let mut runtime = WasmRuntime::new().unwrap();

        // WASM module that tests heap operations
        let wasm_bytes = wat::parse_str(
            r#"
            (module
                (import "runtime" "heap_alloc" (func $heap_alloc (param i32) (result i64)))
                (import "runtime" "heap_retain" (func $heap_retain (param i64)))
                (import "runtime" "heap_release" (func $heap_release (param i64)))
                (memory (export "memory") 1)
                
                (func (export "test_heap") (result i64)
                    (local $obj i64)
                    ;; Allocate heap object with 2 words
                    i32.const 2
                    call $heap_alloc
                    local.set $obj
                    
                    ;; Retain it
                    local.get $obj
                    call $heap_retain
                    
                    ;; Return the heap index
                    local.get $obj
                )
            )
            "#,
        )
        .expect("Failed to parse WAT");

        let mut module = runtime
            .load_module(&wasm_bytes)
            .expect("Failed to load module");
        let result = module
            .call_function("test_heap", &[])
            .expect("Failed to call function");

        assert_eq!(result.len(), 1, "Should return one value");
        assert_ne!(result[0], 0, "Heap allocation should return non-zero index");
    }

    #[test]
    fn test_array_operations() {
        let mut runtime = WasmRuntime::new().unwrap();

        // WASM module that tests array operations
        let wasm_bytes = wat::parse_str(
            r#"
            (module
                (import "runtime" "array_alloc" (func $array_alloc (param i64 i32) (result i64)))
                (import "runtime" "array_get_elem" (func $array_get_elem (param i32 i64 i64 i32)))
                (import "runtime" "array_set_elem" (func $array_set_elem (param i64 i64 i32 i32)))
                (memory (export "memory") 1)
                
                (func (export "test_array") (result i64)
                    (local $arr i64)
                    ;; Store some values in memory
                    i32.const 0
                    i64.const 42
                    i64.store
                    i32.const 8
                    i64.const 99
                    i64.store
                    
                    ;; Allocate array from memory (ptr=0 as i64, size=2)
                    i64.const 0
                    i32.const 2
                    call $array_alloc
                    local.set $arr
                    
                    ;; Get first element into memory at offset 16
                    ;; (dst_ptr=16, array, index=0 as i64, elem_size=1)
                    i32.const 16
                    local.get $arr
                    i64.const 0
                    i32.const 1
                    call $array_get_elem

                    ;; Load the result from memory offset 16
                    i32.const 16
                    i64.load
                )
            )
            "#,
        )
        .expect("Failed to parse WAT");

        let mut module = runtime
            .load_module(&wasm_bytes)
            .expect("Failed to load module");
        let result = module
            .call_function("test_array", &[])
            .expect("Failed to call function");

        assert_eq!(result.len(), 1, "Should return one value");
        assert_eq!(result[0], 42, "Array should contain stored value");
    }

    #[test]
    fn test_load_generated_wasm() {
        use std::path::PathBuf;

        // Use workspace root relative path
        let mut wasm_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        wasm_path.pop(); // Remove mimium-lang
        wasm_path.pop(); // Remove lib
        wasm_path.pop(); // Remove crates
        wasm_path.push("tmp");
        wasm_path.push("test_integration.wasm");

        // Skip test if the file doesn't exist (e.g., in CI environment)
        if !wasm_path.exists() {
            eprintln!("Skipping test_load_generated_wasm: file not found at {wasm_path:?}");
            return;
        }

        eprintln!("Loading WASM from: {wasm_path:?}");
        let wasm_bytes = std::fs::read(&wasm_path).expect("Failed to read generated WASM file");

        let mut runtime = WasmRuntime::new().unwrap();
        let result = runtime.load_module(&wasm_bytes);

        assert!(
            result.is_ok(),
            "Should load generated WASM module: {:?}",
            result.err()
        );

        let mut module = result.unwrap();

        // Try to call the dsp function if it exists
        if let Ok(result) = module.call_function("fn_0", &[]) {
            eprintln!("fn_0 returned: {result:?}");
        }
    }
}
