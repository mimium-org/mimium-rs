// Wasmtime-based WASM runtime
//
// This module provides execution of WASM modules generated by the WASM backend.
// It uses Wasmtime as the WASM runtime and bridges RuntimePrimitives to host functions.

pub mod engine;

use crate::runtime::primitives::Word;
use crate::runtime::vm::heap::{self, HeapStorage};
use std::collections::HashMap;
use wasmtime::{Caller, Config, Engine, Linker, Module, OptLevel, Store};

/// WASM runtime state
pub struct WasmRuntime {
    /// Wasmtime engine
    engine: Engine,
    /// Linker for connecting host functions
    linker: Linker<RuntimeState>,
}

/// Per-instance runtime state passed to host functions
pub struct RuntimeState {
    /// Linear memory pointer (set after instantiation)
    memory: Option<wasmtime::Memory>,
    /// Heap storage for dynamic allocations
    heap: HeapStorage,
    /// Array storage (array ID -> array data)
    arrays: HashMap<Word, Vec<Word>>,
    /// State storage stack for @ operator
    state_stack: Vec<Word>,
    /// Current time (for runtime_get_now)
    current_time: u64,
    /// Sample rate (for runtime_get_samplerate)
    sample_rate: f64,
}

impl Default for RuntimeState {
    fn default() -> Self {
        Self {
            memory: None,
            heap: HeapStorage::default(),
            arrays: HashMap::new(),
            state_stack: Vec::new(),
            current_time: 0,
            sample_rate: 44100.0,
        }
    }
}

impl WasmRuntime {
    /// Create a new WASM runtime with JIT compilation
    pub fn new() -> Result<Self, String> {
        // Configure Wasmtime with JIT compiler and optimizations
        let mut config = Config::new();
        
        // Enable Cranelift JIT compiler with optimization level Speed
        config.cranelift_opt_level(OptLevel::Speed);
        
        // Enable parallel compilation for faster module loading
        config.parallel_compilation(true);
        
        // Enable WASM features that may improve performance
        config.wasm_simd(true); // SIMD operations
        config.wasm_bulk_memory(true); // Bulk memory operations
        
        let engine = Engine::new(&config)
            .map_err(|e| format!("Failed to create WASM engine: {e}"))?;
        let mut linker = Linker::new(&engine);

        // Register all runtime primitive host functions
        Self::register_runtime_primitives(&mut linker)?;

        Ok(Self { engine, linker })
    }

    /// Load and instantiate a WASM module
    pub fn load_module(&mut self, wasm_bytes: &[u8]) -> Result<WasmModule, String> {
        let module = Module::from_binary(&self.engine, wasm_bytes)
            .map_err(|e| format!("Failed to load WASM module: {e:#}"))?;

        let mut store = Store::new(&self.engine, RuntimeState::default());

        let instance = self
            .linker
            .instantiate(&mut store, &module)
            .map_err(|e| format!("Failed to instantiate WASM module: {e:#}"))?;

        // Get memory export
        let memory = instance
            .get_memory(&mut store, "memory")
            .ok_or("WASM module does not export memory")?;

        store.data_mut().memory = Some(memory);

        Ok(WasmModule {
            module,
            store,
            instance,
        })
    }

    /// Register all runtime primitive host functions
    fn register_runtime_primitives(linker: &mut Linker<RuntimeState>) -> Result<(), String> {
        macro_rules! register {
            ($($name:expr => $func:expr),* $(,)?) => {
                $(
                    linker
                        .func_wrap("runtime", $name, $func)
                        .map_err(|e| format!("Failed to register {}: {}", $name, e))?;
                )*
            };
        }

        register! {
            // Heap operations
            "heap_alloc" => heap_alloc_host,
            "heap_retain" => heap_retain_host,
            "heap_release" => heap_release_host,
            "heap_load" => heap_load_host,
            "heap_store" => heap_store_host,
            // Box operations
            "box_alloc" => box_alloc_host,
            "box_load" => box_load_host,
            "box_clone" => box_clone_host,
            "box_release" => box_release_host,
            "box_store" => box_store_host,
            // UserSum operations
            "usersum_clone" => usersum_clone_host,
            "usersum_release" => usersum_release_host,
            // Closure operations
            "closure_make" => closure_make_host,
            "closure_close" => closure_close_host,
            "closure_call" => closure_call_host,
            // State operations
            "state_push" => state_push_host,
            "state_pop" => state_pop_host,
            "state_get" => state_get_host,
            "state_set" => state_set_host,
            "state_delay" => state_delay_host,
            "state_mem" => state_mem_host,
            // Array operations
            "array_alloc" => array_alloc_host,
            "array_get_elem" => array_get_elem_host,
            "array_set_elem" => array_set_elem_host,
            // Runtime globals
            "runtime_get_now" => runtime_get_now_host,
            "runtime_get_samplerate" => runtime_get_samplerate_host,
        }

        Ok(())
    }
}

impl Default for WasmRuntime {
    fn default() -> Self {
        Self::new().expect("Failed to create WASM runtime")
    }
}

/// WASM module instance
pub struct WasmModule {
    #[allow(dead_code)]
    module: Module,
    store: Store<RuntimeState>,
    instance: wasmtime::Instance,
}

impl WasmModule {
    /// Call a function exported by the WASM module
    pub fn call_function(&mut self, name: &str, args: &[Word]) -> Result<Vec<Word>, String> {
        let func = self
            .instance
            .get_func(&mut self.store, name)
            .ok_or_else(|| format!("Function '{name}' not found in WASM module"))?;

        // Convert args to wasmtime values
        let wasm_args: Vec<wasmtime::Val> =
            args.iter().map(|&w| wasmtime::Val::I64(w as i64)).collect();

        // Prepare results buffer
        let mut results = vec![wasmtime::Val::I64(0); func.ty(&self.store).results().len()];

        // Call function
        func.call(&mut self.store, &wasm_args, &mut results)
            .map_err(|e| format!("Failed to call function '{name}': {e}"))?;

        // Convert results back to Words
        Ok(results
            .into_iter()
            .map(|v| match v {
                wasmtime::Val::I64(i) => i as u64,
                wasmtime::Val::F64(f) => f, // Already in bits representation
                wasmtime::Val::I32(i) => i as u64,
                wasmtime::Val::F32(f) => f as u64, // Already in bits representation
                _ => 0,
            })
            .collect())
    }
}

// Host function implementations

fn heap_alloc_host(mut caller: Caller<'_, RuntimeState>, size_words: i32) -> i64 {
    log::trace!("heap_alloc_host: size_words={size_words}");
    let state = caller.data_mut();
    let heap_obj = heap::HeapObject::new(size_words as usize);
    let heap_idx = state.heap.insert(heap_obj);

    // Convert HeapIdx to Word for WASM
    // We use the slotmap key's internal representation
    unsafe { std::mem::transmute::<heap::HeapIdx, u64>(heap_idx) as i64 }
}

fn heap_retain_host(mut caller: Caller<'_, RuntimeState>, obj: i64) {
    log::trace!("heap_retain_host: obj={obj}");
    let state = caller.data_mut();
    let heap_idx: heap::HeapIdx = unsafe { std::mem::transmute::<u64, heap::HeapIdx>(obj as u64) };
    heap::heap_retain(&mut state.heap, heap_idx);
}

fn heap_release_host(mut caller: Caller<'_, RuntimeState>, obj: i64) {
    log::trace!("heap_release_host: obj={obj}");
    let state = caller.data_mut();
    let heap_idx: heap::HeapIdx = unsafe { std::mem::transmute::<u64, heap::HeapIdx>(obj as u64) };
    heap::heap_release(&mut state.heap, heap_idx);
}

fn heap_load_host(mut caller: Caller<'_, RuntimeState>, dst_ptr: i32, obj: i64, size_words: i32) {
    log::trace!("heap_load_host: dst_ptr={dst_ptr}, obj={obj}, size_words={size_words}");

    let heap_idx: heap::HeapIdx = unsafe { std::mem::transmute::<u64, heap::HeapIdx>(obj as u64) };
    let size = size_words as usize;

    // Get heap data
    let data = {
        let state = caller.data();
        state
            .heap
            .get(heap_idx)
            .map(|heap_obj| heap_obj.data[..size].to_vec())
            .expect("heap_load: invalid heap index")
    };

    // Write to linear memory
    let memory = caller.data().memory.expect("Memory not initialized");
    let offset = dst_ptr as usize;
    let bytes = unsafe {
        std::slice::from_raw_parts(
            data.as_ptr() as *const u8,
            size * std::mem::size_of::<Word>(),
        )
    };
    memory
        .write(&mut caller, offset, bytes)
        .expect("Failed to write to WASM memory");
}

fn heap_store_host(mut caller: Caller<'_, RuntimeState>, obj: i64, src_ptr: i32, size_words: i32) {
    log::trace!("heap_store_host: obj={obj}, src_ptr={src_ptr}, size_words={size_words}");

    let heap_idx: heap::HeapIdx = unsafe { std::mem::transmute::<u64, heap::HeapIdx>(obj as u64) };
    let size = size_words as usize;

    // Read from linear memory
    let mut buffer = vec![0u64; size];
    let memory = caller.data().memory.expect("Memory not initialized");
    let offset = src_ptr as usize;
    let bytes = unsafe {
        std::slice::from_raw_parts_mut(
            buffer.as_mut_ptr() as *mut u8,
            size * std::mem::size_of::<Word>(),
        )
    };
    memory
        .read(&caller, offset, bytes)
        .expect("Failed to read from WASM memory");

    // Write to heap
    let state = caller.data_mut();
    let heap_obj = state
        .heap
        .get_mut(heap_idx)
        .expect("heap_store: invalid heap index");
    heap_obj.data[..size].copy_from_slice(&buffer[..size]);
}

fn box_alloc_host(mut caller: Caller<'_, RuntimeState>, src_ptr: i32, size_words: i32) -> i64 {
    log::trace!("box_alloc_host: src_ptr={src_ptr}, size_words={size_words}");

    let size = size_words as usize;

    // Read from linear memory
    let mut buffer = vec![0u64; size];
    let memory = caller.data().memory.expect("Memory not initialized");
    let offset = src_ptr as usize;
    let bytes = unsafe {
        std::slice::from_raw_parts_mut(
            buffer.as_mut_ptr() as *mut u8,
            size * std::mem::size_of::<Word>(),
        )
    };
    memory
        .read(&caller, offset, bytes)
        .expect("Failed to read from WASM memory");

    // Create heap object
    let state = caller.data_mut();
    let heap_obj = heap::HeapObject::with_data(buffer);
    let heap_idx = state.heap.insert(heap_obj);

    unsafe { std::mem::transmute::<heap::HeapIdx, u64>(heap_idx) as i64 }
}

fn box_load_host(caller: Caller<'_, RuntimeState>, dst_ptr: i32, obj: i64, size_words: i32) {
    log::trace!("box_load_host: dst_ptr={dst_ptr}, obj={obj}, size_words={size_words}");

    // Same as heap_load
    heap_load_host(caller, dst_ptr, obj, size_words);
}

fn box_clone_host(mut caller: Caller<'_, RuntimeState>, obj: i64) {
    log::trace!("box_clone_host: obj={obj}");

    // Same as heap_retain
    let state = caller.data_mut();
    let heap_idx: heap::HeapIdx = unsafe { std::mem::transmute::<u64, heap::HeapIdx>(obj as u64) };
    heap::heap_retain(&mut state.heap, heap_idx);
}

fn box_release_host(mut caller: Caller<'_, RuntimeState>, obj: i64) {
    log::trace!("box_release_host: obj={obj}");

    // Same as heap_release
    let state = caller.data_mut();
    let heap_idx: heap::HeapIdx = unsafe { std::mem::transmute::<u64, heap::HeapIdx>(obj as u64) };
    heap::heap_release(&mut state.heap, heap_idx);
}

fn box_store_host(caller: Caller<'_, RuntimeState>, obj: i64, src_ptr: i32, size_words: i32) {
    log::trace!("box_store_host: obj={obj}, src_ptr={src_ptr}, size_words={size_words}");

    // Same as heap_store
    heap_store_host(caller, obj, src_ptr, size_words);
}

// UserSum operations

fn usersum_clone_host(_caller: Caller<'_, RuntimeState>, obj: i64, type_id: i32) {
    // TODO: Implement actual usersum clone
    log::trace!("usersum_clone_host: obj={obj}, type_id={type_id}");
}

fn usersum_release_host(_caller: Caller<'_, RuntimeState>, obj: i64, type_id: i32) {
    // TODO: Implement actual usersum release
    log::trace!("usersum_release_host: obj={obj}, type_id={type_id}");
}

// Closure operations

fn closure_make_host(
    _caller: Caller<'_, RuntimeState>,
    fn_idx: i32,
    captured_ptr: i32,
    captured_size: i32,
) -> i64 {
    // TODO: Implement actual closure creation
    log::trace!(
        "closure_make_host: fn_idx={fn_idx}, captured_ptr={captured_ptr}, captured_size={captured_size}"
    );
    0 // Placeholder
}

fn closure_close_host(
    _caller: Caller<'_, RuntimeState>,
    closure: i64,
    captured_ptr: i32,
    captured_size: i32,
) {
    // TODO: Implement actual closure closing
    log::trace!(
        "closure_close_host: closure={closure}, captured_ptr={captured_ptr}, captured_size={captured_size}"
    );
}

fn closure_call_host(
    _caller: Caller<'_, RuntimeState>,
    closure: i64,
    dst_ptr: i32,
    size_words: i32,
) {
    // TODO: Implement actual closure call
    log::trace!("closure_call_host: closure={closure}, dst_ptr={dst_ptr}, size_words={size_words}");
}

// State operations

fn state_push_host(mut caller: Caller<'_, RuntimeState>, offset: i64) {
    log::trace!("state_push_host: offset={offset}");
    let state = caller.data_mut();
    state.state_stack.push(offset as Word);
}

fn state_pop_host(mut caller: Caller<'_, RuntimeState>) {
    log::trace!("state_pop_host");
    let state = caller.data_mut();
    state.state_stack.pop().expect("state_pop: stack underflow");
}

fn state_get_host(caller: Caller<'_, RuntimeState>, state_idx: i32) -> i64 {
    log::trace!("state_get_host: state_idx={state_idx}");
    // TODO: Implement actual state tree access
    // For now, return 0 (will need state tree integration)
    let _ = caller;
    0
}

fn state_set_host(caller: Caller<'_, RuntimeState>, state_idx: i32, value: i64) {
    log::trace!("state_set_host: state_idx={state_idx}, value={value}");
    // TODO: Implement actual state tree modification
    let _ = (caller, value);
}

fn state_delay_host(caller: Caller<'_, RuntimeState>, input: i64, samples: i32) -> i64 {
    log::trace!("state_delay_host: input={input}, samples={samples}");
    // TODO: Implement actual delay line
    // For now, pass through input
    let _ = (caller, samples);
    input
}

fn state_mem_host(caller: Caller<'_, RuntimeState>, input: i64, init: i64) -> i64 {
    log::trace!("state_mem_host: input={input}, init={init}");
    // TODO: Implement actual memory (one-sample delay)
    // For now, return init on first call
    let _ = (caller, input);
    init
}

// Array operations

fn array_alloc_host(mut caller: Caller<'_, RuntimeState>, src_ptr: i32, size: i32) -> i64 {
    log::trace!("array_alloc_host: src_ptr={src_ptr}, size={size}");

    let size_usize = size as usize;

    // Read from linear memory
    let mut buffer = vec![0u64; size_usize];
    let memory = caller.data().memory.expect("Memory not initialized");
    let offset = src_ptr as usize;
    let bytes = unsafe {
        std::slice::from_raw_parts_mut(
            buffer.as_mut_ptr() as *mut u8,
            size_usize * std::mem::size_of::<Word>(),
        )
    };
    memory
        .read(&caller, offset, bytes)
        .expect("Failed to read from WASM memory");

    // Generate unique array ID
    let state = caller.data_mut();
    let array_id = (state.arrays.len() + 1) as Word;
    state.arrays.insert(array_id, buffer);

    array_id as i64
}

fn array_get_elem_host(caller: Caller<'_, RuntimeState>, array: i64, index: i32) -> i64 {
    log::trace!("array_get_elem_host: array={array}, index={index}");

    let state = caller.data();
    let array_data = state
        .arrays
        .get(&(array as Word))
        .expect("array_get_elem: invalid array ID");
    let idx = index as usize;

    if idx >= array_data.len() {
        panic!("array_get_elem: index out of bounds");
    }

    array_data[idx] as i64
}

fn array_set_elem_host(mut caller: Caller<'_, RuntimeState>, array: i64, index: i32, value: i64) {
    log::trace!("array_set_elem_host: array={array}, index={index}, value={value}");

    let state = caller.data_mut();
    let array_data = state
        .arrays
        .get_mut(&(array as Word))
        .expect("array_set_elem: invalid array ID");
    let idx = index as usize;

    if idx >= array_data.len() {
        panic!("array_set_elem: index out of bounds");
    }

    array_data[idx] = value as Word;
}

// Runtime globals

fn runtime_get_now_host(caller: Caller<'_, RuntimeState>) -> i64 {
    log::trace!("runtime_get_now_host");
    let state = caller.data();
    state.current_time as i64
}

fn runtime_get_samplerate_host(caller: Caller<'_, RuntimeState>) -> f64 {
    log::trace!("runtime_get_samplerate_host");
    let state = caller.data();
    state.sample_rate
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_wasm_runtime_create() {
        let runtime = WasmRuntime::new();
        assert!(runtime.is_ok(), "Should create WASM runtime");
    }

    #[test]
    fn test_wasm_runtime_load_empty_module() {
        let mut runtime = WasmRuntime::new().unwrap();

        // Minimal valid WASM module with memory export
        let wasm_bytes = wat::parse_str(
            r#"
            (module
                (memory (export "memory") 1)
            )
            "#,
        )
        .expect("Failed to parse WAT");

        let result = runtime.load_module(&wasm_bytes);
        assert!(result.is_ok(), "Should load minimal WASM module");
    }

    #[test]
    fn test_heap_operations() {
        let mut runtime = WasmRuntime::new().unwrap();

        // WASM module that tests heap operations
        let wasm_bytes = wat::parse_str(
            r#"
            (module
                (import "runtime" "heap_alloc" (func $heap_alloc (param i32) (result i64)))
                (import "runtime" "heap_retain" (func $heap_retain (param i64)))
                (import "runtime" "heap_release" (func $heap_release (param i64)))
                (memory (export "memory") 1)
                
                (func (export "test_heap") (result i64)
                    (local $obj i64)
                    ;; Allocate heap object with 2 words
                    i32.const 2
                    call $heap_alloc
                    local.set $obj
                    
                    ;; Retain it
                    local.get $obj
                    call $heap_retain
                    
                    ;; Return the heap index
                    local.get $obj
                )
            )
            "#,
        )
        .expect("Failed to parse WAT");

        let mut module = runtime
            .load_module(&wasm_bytes)
            .expect("Failed to load module");
        let result = module
            .call_function("test_heap", &[])
            .expect("Failed to call function");

        assert_eq!(result.len(), 1, "Should return one value");
        assert_ne!(result[0], 0, "Heap allocation should return non-zero index");
    }

    #[test]
    fn test_array_operations() {
        let mut runtime = WasmRuntime::new().unwrap();

        // WASM module that tests array operations
        let wasm_bytes = wat::parse_str(
            r#"
            (module
                (import "runtime" "array_alloc" (func $array_alloc (param i32 i32) (result i64)))
                (import "runtime" "array_get_elem" (func $array_get_elem (param i64 i32) (result i64)))
                (import "runtime" "array_set_elem" (func $array_set_elem (param i64 i32 i64)))
                (memory (export "memory") 1)
                
                (func (export "test_array") (result i64)
                    (local $arr i64)
                    ;; Store some values in memory
                    i32.const 0
                    i64.const 42
                    i64.store
                    i32.const 8
                    i64.const 99
                    i64.store
                    
                    ;; Allocate array from memory (ptr=0, size=2)
                    i32.const 0
                    i32.const 2
                    call $array_alloc
                    local.set $arr
                    
                    ;; Get first element
                    local.get $arr
                    i32.const 0
                    call $array_get_elem
                    
                    ;; Return it (should be 42)
                )
            )
            "#,
        )
        .expect("Failed to parse WAT");

        let mut module = runtime
            .load_module(&wasm_bytes)
            .expect("Failed to load module");
        let result = module
            .call_function("test_array", &[])
            .expect("Failed to call function");

        assert_eq!(result.len(), 1, "Should return one value");
        assert_eq!(result[0], 42, "Array should contain stored value");
    }

    #[test]
    fn test_load_generated_wasm() {
        use std::path::PathBuf;

        // Use workspace root relative path
        let mut wasm_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
        wasm_path.pop(); // Remove mimium-lang
        wasm_path.pop(); // Remove lib
        wasm_path.pop(); // Remove crates
        wasm_path.push("tmp");
        wasm_path.push("test_integration.wasm");

        // Skip test if the file doesn't exist (e.g., in CI environment)
        if !wasm_path.exists() {
            eprintln!(
                "Skipping test_load_generated_wasm: file not found at {:?}",
                wasm_path
            );
            return;
        }

        eprintln!("Loading WASM from: {:?}", wasm_path);
        let wasm_bytes = std::fs::read(&wasm_path).expect("Failed to read generated WASM file");

        let mut runtime = WasmRuntime::new().unwrap();
        let result = runtime.load_module(&wasm_bytes);

        assert!(
            result.is_ok(),
            "Should load generated WASM module: {:?}",
            result.err()
        );

        let mut module = result.unwrap();

        // Try to call the dsp function if it exists
        if let Ok(result) = module.call_function("fn_0", &[]) {
            eprintln!("fn_0 returned: {:?}", result);
        }
    }
}
