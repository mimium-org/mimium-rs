fn sec2samp(sec){
    sec*48000.0
}
fn countup(active){
    let r  =(self+1.0);
    if (active) r else 0.0
}
fn countupn(time,active){
    let res = countup(active)
    if(res<time) res else 0.0
}
fn hold(time,active){
    countupn(time,active)>0.0
}
fn adsr(attack,decay,sustain,release,input){
    atsig = min(1.0,(self + 1.0/sec2samp(attack)))
    decsig = max(sustain,(self-1.0/sec2samp(decay)))
    releasesig =max(0,(self-1.0/sec2samp(release)))
    at_or_dec = hold(sec2samp(attack),input>0.0)*input
    at_dec_sus_sig = if (at_or_dec) atsig else decsig
    if (input>0.5) at_dec_sus_sig else releasesig
}