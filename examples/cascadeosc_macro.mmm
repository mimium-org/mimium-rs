//same as cascadeosc.mmm, but written with new multi-stage computation feature.
// include("osc.mmm")
#stage(main)

let PI = 3.14159265359

let phasor_shift =  |freq,phase_shift|{
    (self + freq/samplerate + phase_shift)%1.0
}

let sinwave = |freq,phase|{
    phasor_shift(freq,phase)*2.0*PI |> sin
}
let osc = |freq|{
  sinwave(freq,0.0)
}

#stage(macro)
fn cascade (n,gen:`(float)->float)->`(float)->float{
    if (n>0.0){

        let multiplier = 1.0-(1.0/(n*3)) |> lift_f
        `{|rate| rate + ($gen)(rate/3)* 0.5 * rate* $multiplier  |> $cascade(n - 1.0 ,gen) }
    }else{
        `{|rate| ($gen)(rate)}
    }
}

#stage(main)
fn fbdelay(input,time,fb,mix){
    input*mix + (1.0-mix) * delay(40001.0,(input+self*fb),time)
}
fn dsp(){
    let time_r = sinwave(0.15,0) *100
    let time_l = sinwave(0.6,0) *200
    // let time_l =100
    let f = 100
    let f = Slider!("freq",100,1,200) + osc(0.2)*50 +5
    let r =  (f |> cascade!(1000.0,`osc))*0.3 ;
    let l = fbdelay(r,20400+time_l,0.99,0.7)
             |> Probe!("L")
    let r = fbdelay(r,20000+time_r,0.99,0.7)
             |> Probe!("R")
    (l,r)
    
}
